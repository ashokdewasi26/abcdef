# Copyright (C) 2025. BMW CTW. All rights reserved.
import logging
import time

from mtee.testing.tools import retry_on_except
from selenium.webdriver.common.by import By
import si_test_idcevo.si_test_helpers.test_helpers as utils
from si_test_idcevo.si_test_helpers.pages.idcevo.connectivity_page import ConnectivityPage as Connectivity
from si_test_idcevo.si_test_helpers.pages.real_phone.android_pop_up_page import AndroidPopUp
from si_test_idcevo.si_test_helpers.pages.real_phone.android_settings_page import AndroidSettings


logger = logging.getLogger(__name__)  # pylint: disable=invalid-name


class BluetoothUtils:
    def __init__(self, test):
        self.test = test

    @retry_on_except(retry_count=1)
    def connect_new_device(self, real_phone):
        """
        Connects a real phone device to the IDCEvo Bluetooth.

        This method automates the process of pairing a real phone with the IDCEvo head unit by:
            - Navigating through the IDCEvo UI to the Bluetooth connections menu.
            - Click on "Smartphones" to see paired devices
            - Initiating the "Connect new device" workflow.
            - Identifying the IDCEvo Bluetooth device name.
            - Attempting up to three times to connect to the IDCEvo Bluetooth device from the real phone.
            - Waiting for the pairing codes to appear on both devices and verifying they match.
            - Make sure the pairing code generated by IDCEvo is the same as the one showing on real phone
            - Accepting the pairing prompts on both the real phone and the IDCEvo system.
            - Handling additional pop-ups such as message access requests and Android Auto prompts.
            - Capturing screenshots and UI dumps at various stages for debugging purposes.

        Args:
            real_phone: An object representing the real phone to be paired, which must provide methods for UI
             interaction and screenshot capture.

        Raises:
            RuntimeError: If the IDCEvo Bluetooth device name cannot be found in the "Connect new device" menu.
            AssertionError: If the pairing codes on the IDCEvo system and the real phone do not match.
        """
        # Open IDCEvo Connections Menu
        warm_start_cmd = Connectivity.get_command_warm_hot_start()
        Connectivity.start_activity(warm_start_cmd)

        # Click on "Smartphones" to see paired devices
        smartphones_button = self.test.driver.find_element(*Connectivity.SMARTPHONES)
        smartphones_button.click()
        time.sleep(1)

        # Click on "Connect new device"
        connect_new_device_button = self.test.driver.find_element(
            By.ID, "TextAtom:string/wiserv_settings_device_list_add_device_bt"
        )
        connect_new_device_button.click()
        time.sleep(1)

        # Retrieve IDCEvo Bluetooth device name
        try:
            idcevo_bt_device_elem = self.test.driver.find_element(*Connectivity.IDCEVO_BT_ID)
        except Exception as e:
            raise RuntimeError(
                "IDCEvo Bluetooth device name not found under 'Connect new device' menu. "
                f"The following exception was obtained:\n {e}"
            )
        idcevo_bt_device_name = idcevo_bt_device_elem.get_attribute("text")

        rp_pair_number = None
        # Try to click connect to IDCEvo Bluetooth device up to 3 times
        for i in range(3):
            utils.get_screenshot_and_dump(self.test, self.test.results_dir, f"idcevo_before_connecting_real_phone_{i}")
            real_phone.take_real_phone_target_screenshot(
                results_dir=self.test.results_dir,
                file_name=f"real_phone_before_connecting_idcevo_{i}",
            )
            utils.get_xml_dump(
                real_phone.real_phone_driver, self.test.results_dir, f"real_phone_before_connecting_idcevo_{i}"
            )

            # Wait until IDCevo Bluetooth device name is visible on real phone (sometimes it takes a while)
            idcevo_bt_device = real_phone.wait_to_check_visible_element(
                check_elem_visible=Connectivity.IDCEVO_BT_ID, web_driver_timeout=30
            )
            if idcevo_bt_device and idcevo_bt_device.get_attribute("text") == idcevo_bt_device_name:
                idcevo_bt_device.click()
                time.sleep(1)

            # Retrieve connections' pairing code
            rp_pair_number = real_phone.wait_to_check_visible_element(
                check_elem_visible=AndroidSettings.PAIRING_SUBHEAD, web_driver_timeout=5
            )
            idcevo_pair_string = Connectivity.wait_to_check_visible_element(
                Connectivity.PAIRING_CONFIRMATION_CODE_ID, web_driver_timeout=5
            )
            if rp_pair_number and idcevo_pair_string:
                logger.info("Pairing code found on HU and real phone after %d attempts", i + 1)
                break

        # Make sure pairing codes match on both devices
        idcevo_pair_code = idcevo_pair_string.text.split(": ")[1]
        assert (
            idcevo_pair_code == rp_pair_number.text
        ), f"Pair code of IDCEvo: '{idcevo_pair_code}' doesn't match real phone code: '{rp_pair_number.text}'"

        # Accept pairing on real phone
        pair_connect = real_phone.wait_to_check_visible_element(AndroidSettings.PAIR_CONNECT)
        if pair_connect:
            pair_connect.click()
            time.sleep(1)
        pair = real_phone.check_visibility_of_element(AndroidSettings.PAIR)
        pair.click()
        time.sleep(1)

        # Accept pairing on IDCEvo
        accept_bt_connection = Connectivity.check_visibility_of_element(Connectivity.ACCEPT_BLUETOOTH_CONNECTION)
        accept_bt_connection.click()
        time.sleep(1)

        # If "Allow access to messages" shows up, click "Don't allow"
        dont_allow = real_phone.wait_to_check_visible_element(AndroidPopUp.BUTTON2)
        if dont_allow:
            dont_allow.click()
            time.sleep(1)

        # If "Start Android Auto" pop up shows up, click "Connect telephone without Apple CarPlay"
        start_android_auto = Connectivity.wait_to_check_visible_element(Connectivity.START_ANDROID_AUTO)
        if start_android_auto:
            self.test.take_apinext_target_screenshot(self.test.results_dir, "start_android_auto_pop_up")
            continue_without_android_auto = self.test.driver.find_element(*Connectivity.CONTINUE_WITHOUT_ANDROID_AUTO)
            continue_without_android_auto.click()
            time.sleep(1)
            self.test.take_apinext_target_screenshot(
                self.test.results_dir,
                "Smartphones_menu_after_connecting_real_phone",
            )
        # Final UI info gathering for posterior debug
        utils.get_screenshot_and_dump(
            self.test, self.test.results_dir, f"FINAL_idcevo_after_connecting_real_phone_{i}"
        )
        real_phone.take_real_phone_target_screenshot(
            results_dir=self.test.results_dir,
            file_name=f"FINAL_real_phone_after_connecting_idcevo_{i}",
        )
        utils.get_xml_dump(
            real_phone.real_phone_driver, self.test.results_dir, f"FINAL_real_phone_after_connecting_idcevo_{i}"
        )
